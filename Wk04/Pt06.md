# Wk04x06 - Parsing text

## Returning functions from functions

Much like is common in Go, functions can be returned from other functions as values.

```haskell
Prelude> gen_add_n = \n ->  \x ->  x + n
Prelude> plus_three = gen_add_n 3
Prelude> plus_three 6
9
```

This isn't limited to numerical constants - it can be any operator, type or whatever.

## Methods of parsing text

* A tree-type data structure that is generated by the parser and traversed by various functions
* No parsing - instead, prompting for input from a user in a weird format
* Handwriting a parser by hand, using functions like `split` in Python
  * Not reusable
* Regular expressions! 
  * Good for simple stuff, but not reusable
* Parser combinators
* Parser generators
  * eg `yacc`, `bison`, `antlr`, `happy`
  * Best for large, complicated parsers, like those found in programming languages.

## Parser combinators

Parser combinators are functions that allow you to combine small parsers into larger ones. They take functions as arguments and return functions.

A parser combinator library will provide both basic parsers (for words, numbers, etc) and combinators.

### Parsec

One of the most widely used parser combinators for Haskell is called Parsec, which operates in a monad. It's touted as being robust, flexible, expressive and efficient.

## Forming a parser

Say we want to take some text in the form `<tag>`, where tag must be a word, and return the tag as type `Tag`.

A parser, build with Parsec, would look like this.

```haskell
data Tag = MkTag String -- Remember: `MkTag` is a constructor function that returns an instance of `Tag`.

parseTag :: Parser Tag
parseTag = do -- do, called sequentially
    char '<'
    x <- identifier
    char '>'
    return (MkTag x)
```

`char` asserts that the character at a pointer is a certain character value. If it is not, it throws an error, but if it is it consumes that character from the input string and continues on.

## Testing this parser

Parsec comes with a handy `parseTest` function, that works like this.

```haskell
Prelude> import Text.ParserCombinators.Parsec
Prelude Text.ParserCombinators.Parsec> :set -XFlexibleContexts
Prelude Text.ParserCombinators.Parsec> parseTest (char 'b') "cons"
parse error at (line 1, column 1):
unexpected "c"
expecting "b"
Prelude Text.ParserCombinators.Parsec> parseTest (char 'c') "cons"
'c'
```

```haskell
Prelude> import Text.ParserCombinators.Parsec
Prelude Text.ParserCombinators.Parsec> :set -XFlexibleContexts -- ghci is werid sometimes
Prelude Text.ParserCombinators.Parsec> parseTest (char 'b') "cons"
parse error at (line 1, column 1):
unexpected "c"
expecting "b"
Prelude Text.ParserCombinators.Parsec> parseTest (char 'c') "cons"
'c'

Prelude Text.ParserCombinators.Parsec> data Tag = MkTag String deriving Show

Prelude Text.ParserCombinators.Parsec> :set +m
Prelude Text.ParserCombinators.Parsec> parseDiv = do
Prelude Text.ParserCombinators.Parsec|     string "<div>"
Prelude Text.ParserCombinators.Parsec|     return (MkTag "div")
Prelude Text.ParserCombinators.Parsec|

Prelude Text.ParserCombinators.Parsec> parseTest parseDiv "<div>"
MkTag "div"
Prelude Text.ParserCombinators.Parsec> parseTest parseDiv "potato"
parse error at (line 1, column 1):
unexpected "p"
expecting "<div>"
```

## A basic parser

All parser combinators are functions that return functions. The returned function is what acts on the string, not the parser combinator function itself. The basic parsers (`identifier`, `natural`, `char`, etc) either take no arguments (eg `identifier`) or one or more strings for parameterisation (eg `char`)

```haskell
char = \ch -> \str ->
    -- attempt to match the character `ch`
    -- return that
```

If the match succeeds, the matching string is consumed (removed from the input string), otherwise the original string is returned.

## Parsing options

It's not uncommon that sometimes we want to try to use one parser, and failing that try another one. The choice combinator, `<|>`, will do this for us.

For example, `letter_digit` will match either a letter of a digit.

```haskell
letter_digit :: Parser Char
letter_digit = do
    x <- letter <|> digit
    return x
```

```haskell
Prelude Text.ParserCombinators.Parsec> parseTest letter_digit "b2"
'b'
Prelude Text.ParserCombinators.Parsec> parseTest letter_digit "2b"
'2'
Prelude Text.ParserCombinators.Parsec> parseTest letter_digit "*b"
parse error at (line 1, column 1):
unexpected "*"
expecting letter or digit
```

## Parsing alternative strings

If we wanted to, we could also write a parser that parses only `"foo"` or `"bar"`.

```haskell
foo_bar :: Parser String
foo_bar = do
    xs <- string "bar" <|> string "foo"
    return xs
```

```haskell
Prelude Text.ParserCombinators.Parsec> parseTest foo_bar "foo"
"foo"
Prelude Text.ParserCombinators.Parsec> parseTest foo_bar "bar"
"bar"
Prelude Text.ParserCombinators.Parsec> parseTest foo_bar "baz"
parse error at (line 1, column 1):
unexpected "z"
expecting "bar"
```

However, this is causing an issue. When we try to feed the parser `"baz"`, it's consuming `ba` into the void.

To mitigate this, we can use the `try` function.

```haskell
foo_bar_try :: Parser String
foo_bar_try = do
    xs <- try (string "bar") <|> string "foo"
    return xs
```

## Stuff included with Parsec

Parsec includes various different smaller parsers as part of it. Some of these are:

* `char\; "?"` - `char` is applied to a character, and it gives a parser that matches that character
* `letter` - matches any letter
* `digit` - matches any digit
* `string` - matches a string of characters
* `stringLiteral\; "xyz*"` - matches the string argument
* `many\; p` - matches 0 or mdore occurrences of parser `p`
* `many1\; p` - matches 1 or more occurrences of parser `p`

## Parsing a variable name

A variable name has to start with a letter, only after which it can contain numbers. We can make a parser for this like so:

```haskell
varname :: Parser String
varname = do 
    x <- letter
    xs <- many (letter <|> digit)
    return (x:xs)
```

```haskell
Prelude Text.ParserCombinators.Parsec> parseTest varname "a4cc7*5"
"a4cc7"
Prelude Text.ParserCombinators.Parsec> parseTest varname "34a"
parse error at (line 1, column 1):
unexpected "3"
expecting letter
```
